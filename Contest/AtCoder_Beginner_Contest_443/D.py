T = int(input())

for i in range(T):
    N = int(input())
    R = list(map(int,input().split()))
    ans = 0
    k = 0

"""
    for j in range(N-1):
        if R[j]-R[j+1] > 1:
            ans += (R[j]-R[j+1] - 1)
            R[j] = R[j+1] + 1
        elif R[j]-R[j+1] < -1:
            ans += abs(R[j]-R[j+1]) - 1
            R[j+1] = R[j] + 1
        else:
            None
"""

    for j in range(N-2):
        if R[j] > R[j+1]:
            if R[j+1] > R[j+2]:
                continue
            else:
                while R[j-k] >= R[j-k-1]:
                    ans += R[j] - R[j+1] -1
                    R[j-k] = R[j+1]+1

                k = 0
                while R[j+2+k] >= R[j+3+k]:
                    ans += R[j+2] - R[j+1] -1
                    R[j+2+k] = R[j+1]+1
                    k += 1
    print(ans)


# たぶん右に進んで、R[j]自体を動かしたときにそれまでの駒も動かす必要があるから、それを考慮しないといけない。
# ただ、もう動かせない駒の事を考えないといけないから、それをカウントしとかないといけない？
# いやもっと簡単にできそう。R[j]を中心に3*3マス内に駒があれば良い。いややっぱそれでも上記の事を考慮する必要がある。むずい。
# たぶんDPだから分からないかも。
# サンプルケースの出力結果を見るに、低く見積もってWAなので、やはり上記で間違ってなさそう。
# いや山になっている部分、つまり行が小さい所から見て、そこを中心に右と左を合わせていくアルゴリズムが良さそう。
# 山みたいになっているのが最適解だこれ。